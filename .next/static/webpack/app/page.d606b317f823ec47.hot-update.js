"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-client)/./lib/data.js":
/*!*********************!*\
  !*** ./lib/data.js ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadData: function() { return /* binding */ loadData; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"(app-client)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var geotoolbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! geotoolbox */ \"(app-client)/./node_modules/geotoolbox/src/index.js\");\n/* harmony import */ var _lib_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/state */ \"(app-client)/./lib/state.js\");\n/* __next_internal_client_entry_do_not_use__ loadData auto */ \n\n\nconst POULTRY_PLANTS_CSV = \"../data/poultry_plants_with_sales.csv\";\nconst PLANT_ACCESS_GEOJSON = \"../data/all_states.geojson\";\nconst COUNTERGLOW_FARS = \"../data/counterglow_geojson.geojson\";\nconst getJSON = async (dataPath)=>{\n    const response = await fetch(dataPath);\n    return await response.json();\n};\nconst getPoultryCSV = async (dataPath)=>{\n    const response = await fetch(dataPath);\n    const reader = response.body.getReader();\n    const result = await reader.read(); // raw array\n    const decoder = new TextDecoder(\"utf-8\");\n    const csv = decoder.decode(result.value);\n    return new Promise((resolve, reject)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(csv, {\n            header: true,\n            complete: (results)=>{\n                const data = results.data.map((row)=>({\n                        ...row,\n                        \"Sales Volume (Location)\": parseFloat(row[\"Sales Volume (Location)\"])\n                    }));\n                resolve(data);\n            },\n            error: (error)=>{\n                reject(error);\n            }\n        });\n    });\n};\n// Function to load data\nconst loadData = async ()=>{\n    // Read raw files\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.plantAccess = await getJSON(PLANT_ACCESS_GEOJSON);\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.allStates = _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.plantAccess.features.map((feature)=>feature.properties.state).filter((value, index, array)=>array.indexOf(value) === index).sort();\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.counterglowFarms = await getJSON(COUNTERGLOW_FARS);\n    // Filter FSIS plant data\n    const rawPlants = await getPoultryCSV(POULTRY_PLANTS_CSV);\n    const rawPoultryPlants = rawPlants.filter((row)=>{\n        if (row[\"Animals Processed\"] === \"Chicken\" && row.Size === \"Large\") {\n            return true;\n        } else {\n            return false;\n        }\n    });\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.poultryPlants = (0,geotoolbox__WEBPACK_IMPORTED_MODULE_1__.coords2geo)(rawPoultryPlants, {\n        lat: \"latitude\",\n        lng: \"longitude\"\n    });\n    // Initialize display data\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.filteredStates = [\n        ..._lib_state__WEBPACK_IMPORTED_MODULE_2__.state.allStates\n    ]; // Start with all states selected\n    (0,_lib_state__WEBPACK_IMPORTED_MODULE_2__.updateFilteredData)();\n    _lib_state__WEBPACK_IMPORTED_MODULE_2__.state.data.isDataLoaded = true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbGliL2RhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OERBQzZCO0FBQ1c7QUFFaUI7QUFFekQsTUFBTUkscUJBQXFCO0FBQzNCLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxtQkFBbUI7QUFFekIsTUFBTUMsVUFBVSxPQUFPQztJQUNyQixNQUFNQyxXQUFXLE1BQU1DLE1BQU1GO0lBQzdCLE9BQU8sTUFBTUMsU0FBU0U7QUFDeEI7QUFFQSxNQUFNQyxnQkFBZ0IsT0FBT0o7SUFDM0IsTUFBTUMsV0FBVyxNQUFNQyxNQUFNRjtJQUM3QixNQUFNSyxTQUFTSixTQUFTSyxLQUFLQztJQUM3QixNQUFNQyxTQUFTLE1BQU1ILE9BQU9JLFFBQVEsWUFBWTtJQUNoRCxNQUFNQyxVQUFVLElBQUlDLFlBQVk7SUFDaEMsTUFBTUMsTUFBTUYsUUFBUUcsT0FBT0wsT0FBT007SUFFbEMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCekIsc0RBQVUwQixDQUFDTixLQUFLO1lBQ2RPLFFBQVE7WUFDUkMsVUFBVSxDQUFDQztnQkFDVCxNQUFNQyxPQUFPRCxRQUFRQyxLQUFLQyxJQUFJLENBQUNDLE1BQVM7d0JBQ3RDLEdBQUdBLEdBQUc7d0JBQ04sMkJBQTJCQyxXQUFXRCxHQUFHLENBQUMsMEJBQTBCO29CQUN0RTtnQkFFQVIsUUFBUU07WUFDVjtZQUNBSSxPQUFPLENBQUNBO2dCQUNOVCxPQUFPUztZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsd0JBQXdCO0FBQ2pCLE1BQU1DLFdBQVc7SUFDdEIsaUJBQWlCO0lBQ2pCakMsNkNBQUtBLENBQUM0QixLQUFLTSxjQUFjLE1BQU03QixRQUFRRjtJQUN2Q0gsNkNBQUtBLENBQUM0QixLQUFLTyxZQUFZbkMsNkNBQUtBLENBQUM0QixLQUFLTSxZQUFZRSxTQUMzQ1AsSUFBSSxDQUFDUSxVQUFZQSxRQUFRQyxXQUFXdEMsT0FDcEN1QyxPQUFPLENBQUNuQixPQUFPb0IsT0FBT0MsUUFBVUEsTUFBTUMsUUFBUXRCLFdBQVdvQixPQUN6REc7SUFDSDNDLDZDQUFLQSxDQUFDNEIsS0FBS2dCLG1CQUFtQixNQUFNdkMsUUFBUUQ7SUFFNUMseUJBQXlCO0lBQ3pCLE1BQU15QyxZQUFZLE1BQU1uQyxjQUFjUjtJQUN0QyxNQUFNNEMsbUJBQW1CRCxVQUFVTixPQUFPLENBQUNUO1FBQ3pDLElBQUlBLEdBQUcsQ0FBQyxvQkFBb0IsS0FBSyxhQUFhQSxJQUFJaUIsU0FBUyxTQUFTO1lBQ2xFLE9BQU87UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7SUFDQS9DLDZDQUFLQSxDQUFDNEIsS0FBS29CLGdCQUFnQmpELHNEQUFVQSxDQUFDK0Msa0JBQWtCO1FBQ3RERyxLQUFLO1FBQ0xDLEtBQUs7SUFDUDtJQUVBLDBCQUEwQjtJQUMxQmxELDZDQUFLQSxDQUFDNEIsS0FBS3VCLGlCQUFpQjtXQUFJbkQsNkNBQUtBLENBQUNtQztLQUFVLEVBQUUsaUNBQWlDO0lBQ25GbEMsOERBQWtCQTtJQUNsQkQsNkNBQUtBLENBQUM0QixLQUFLd0IsZUFBZTtBQUM1QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9kYXRhLmpzP2IxMWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUGFwYSBmcm9tIFwicGFwYXBhcnNlXCI7XG5pbXBvcnQgeyBjb29yZHMyZ2VvIH0gZnJvbSBcImdlb3Rvb2xib3hcIjtcblxuaW1wb3J0IHsgc3RhdGUsIHVwZGF0ZUZpbHRlcmVkRGF0YSB9IGZyb20gXCIuLi9saWIvc3RhdGVcIjtcblxuY29uc3QgUE9VTFRSWV9QTEFOVFNfQ1NWID0gXCIuLi9kYXRhL3BvdWx0cnlfcGxhbnRzX3dpdGhfc2FsZXMuY3N2XCI7XG5jb25zdCBQTEFOVF9BQ0NFU1NfR0VPSlNPTiA9IFwiLi4vZGF0YS9hbGxfc3RhdGVzLmdlb2pzb25cIjtcbmNvbnN0IENPVU5URVJHTE9XX0ZBUlMgPSBcIi4uL2RhdGEvY291bnRlcmdsb3dfZ2VvanNvbi5nZW9qc29uXCI7XG5cbmNvbnN0IGdldEpTT04gPSBhc3luYyAoZGF0YVBhdGgpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChkYXRhUGF0aCk7XG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59O1xuXG5jb25zdCBnZXRQb3VsdHJ5Q1NWID0gYXN5bmMgKGRhdGFQYXRoKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZGF0YVBhdGgpO1xuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpOyAvLyByYXcgYXJyYXlcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICBjb25zdCBjc3YgPSBkZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgUGFwYS5wYXJzZShjc3YsIHtcbiAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgIGNvbXBsZXRlOiAocmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzdWx0cy5kYXRhLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICBcIlNhbGVzIFZvbHVtZSAoTG9jYXRpb24pXCI6IHBhcnNlRmxvYXQocm93W1wiU2FsZXMgVm9sdW1lIChMb2NhdGlvbilcIl0pLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGxvYWQgZGF0YVxuZXhwb3J0IGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAvLyBSZWFkIHJhdyBmaWxlc1xuICBzdGF0ZS5kYXRhLnBsYW50QWNjZXNzID0gYXdhaXQgZ2V0SlNPTihQTEFOVF9BQ0NFU1NfR0VPSlNPTik7XG4gIHN0YXRlLmRhdGEuYWxsU3RhdGVzID0gc3RhdGUuZGF0YS5wbGFudEFjY2Vzcy5mZWF0dXJlc1xuICAgIC5tYXAoKGZlYXR1cmUpID0+IGZlYXR1cmUucHJvcGVydGllcy5zdGF0ZSlcbiAgICAuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpXG4gICAgLnNvcnQoKTtcbiAgc3RhdGUuZGF0YS5jb3VudGVyZ2xvd0Zhcm1zID0gYXdhaXQgZ2V0SlNPTihDT1VOVEVSR0xPV19GQVJTKTtcblxuICAvLyBGaWx0ZXIgRlNJUyBwbGFudCBkYXRhXG4gIGNvbnN0IHJhd1BsYW50cyA9IGF3YWl0IGdldFBvdWx0cnlDU1YoUE9VTFRSWV9QTEFOVFNfQ1NWKTtcbiAgY29uc3QgcmF3UG91bHRyeVBsYW50cyA9IHJhd1BsYW50cy5maWx0ZXIoKHJvdykgPT4ge1xuICAgIGlmIChyb3dbXCJBbmltYWxzIFByb2Nlc3NlZFwiXSA9PT0gXCJDaGlja2VuXCIgJiYgcm93LlNpemUgPT09IFwiTGFyZ2VcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBzdGF0ZS5kYXRhLnBvdWx0cnlQbGFudHMgPSBjb29yZHMyZ2VvKHJhd1BvdWx0cnlQbGFudHMsIHtcbiAgICBsYXQ6IFwibGF0aXR1ZGVcIixcbiAgICBsbmc6IFwibG9uZ2l0dWRlXCIsXG4gIH0pO1xuXG4gIC8vIEluaXRpYWxpemUgZGlzcGxheSBkYXRhXG4gIHN0YXRlLmRhdGEuZmlsdGVyZWRTdGF0ZXMgPSBbLi4uc3RhdGUuYWxsU3RhdGVzXTsgLy8gU3RhcnQgd2l0aCBhbGwgc3RhdGVzIHNlbGVjdGVkXG4gIHVwZGF0ZUZpbHRlcmVkRGF0YSgpO1xuICBzdGF0ZS5kYXRhLmlzRGF0YUxvYWRlZCA9IHRydWU7XG59O1xuIl0sIm5hbWVzIjpbIlBhcGEiLCJjb29yZHMyZ2VvIiwic3RhdGUiLCJ1cGRhdGVGaWx0ZXJlZERhdGEiLCJQT1VMVFJZX1BMQU5UU19DU1YiLCJQTEFOVF9BQ0NFU1NfR0VPSlNPTiIsIkNPVU5URVJHTE9XX0ZBUlMiLCJnZXRKU09OIiwiZGF0YVBhdGgiLCJyZXNwb25zZSIsImZldGNoIiwianNvbiIsImdldFBvdWx0cnlDU1YiLCJyZWFkZXIiLCJib2R5IiwiZ2V0UmVhZGVyIiwicmVzdWx0IiwicmVhZCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImNzdiIsImRlY29kZSIsInZhbHVlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwYXJzZSIsImhlYWRlciIsImNvbXBsZXRlIiwicmVzdWx0cyIsImRhdGEiLCJtYXAiLCJyb3ciLCJwYXJzZUZsb2F0IiwiZXJyb3IiLCJsb2FkRGF0YSIsInBsYW50QWNjZXNzIiwiYWxsU3RhdGVzIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwicHJvcGVydGllcyIsImZpbHRlciIsImluZGV4IiwiYXJyYXkiLCJpbmRleE9mIiwic29ydCIsImNvdW50ZXJnbG93RmFybXMiLCJyYXdQbGFudHMiLCJyYXdQb3VsdHJ5UGxhbnRzIiwiU2l6ZSIsInBvdWx0cnlQbGFudHMiLCJsYXQiLCJsbmciLCJmaWx0ZXJlZFN0YXRlcyIsImlzRGF0YUxvYWRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./lib/data.js\n"));

/***/ })

});